const Precalculated = {}

// Pre-calculated S-box
Precalculated.SBOX = [
  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,
];

// Pre-calculated rcon values
// Up to 30 rcon values will be used
Precalculated.RCON = [
  0x01, 0x02, 0x04, 0x08, 0x10,
  0x20, 0x40, 0x80, 0x1b, 0x36,
  0x6c, 0xd8, 0xab, 0x4d, 0x9a,
  0x2f, 0x5e, 0xbc, 0x63, 0xc6,
  0x97, 0x35, 0x6a, 0xd4, 0xb3,
  0x7d, 0xfa, 0xef, 0xc5, 0x91,
];

// Pre-calculated Row-Shifted index
Precalculated.ROW_SHIFT = {
  '16': [0, 5, 10, 15,
    4, 9, 14, 3,
    8, 13, 2, 7,
    12, 1, 6, 11], // 0 1 2 3

  '24': [0, 5, 10, 15,
    4, 9, 14, 19,
    8, 13, 18, 23,
    12, 17, 22, 3,
    16, 21, 2, 7,
    20, 1, 6, 11], // 0 1 2 3

  '32': [0, 5, 14, 19,
    4, 9, 18, 23,
    8, 13, 22, 27,
    12, 17, 26, 31,
    16, 21, 30, 3,
    20, 25, 2, 7,
    24, 29, 6, 11,
    28, 1, 10, 15], // 0 1 3 4
};

// Pre-calculated Galois Multiplication values
// 2, 3, 9, 11, 13, 14

Precalculated.MUL2 = [
  0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
  0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,
  0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,
  0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,
  0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,
  0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,
  0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
  0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,
  0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,
  0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25,
  0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45,
  0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,
  0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85,
  0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5,
  0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,
  0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5,
];

Precalculated.MUL3 = [
  0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11,
  0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21,
  0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,
  0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41,
  0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1,
  0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,
  0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1,
  0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81,
  0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,
  0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba,
  0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea,
  0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,
  0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a,
  0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a,
  0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,
  0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a,
];

Precalculated.MUL9 = [
  0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77,
  0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7,
  0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c,
  0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc,
  0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01,
  0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91,
  0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a,
  0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa,
  0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b,
  0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b,
  0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0,
  0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30,
  0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed,
  0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d,
  0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6,
  0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46,
];

Precalculated.MUL11 = [
  0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69,
  0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9,
  0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12,
  0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2,
  0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f,
  0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f,
  0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4,
  0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54,
  0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e,
  0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e,
  0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5,
  0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55,
  0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68,
  0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8,
  0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13,
  0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3,
];

Precalculated.MUL13 = [
  0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b,
  0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b,
  0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0,
  0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20,
  0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26,
  0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6,
  0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d,
  0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d,
  0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91,
  0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41,
  0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a,
  0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa,
  0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc,
  0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c,
  0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47,
  0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97,
];

Precalculated.MUL14 = [
  0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a,
  0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba,
  0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81,
  0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61,
  0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7,
  0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17,
  0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c,
  0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc,
  0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b,
  0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb,
  0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0,
  0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20,
  0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6,
  0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56,
  0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d,
  0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d,
];

const root = (
  (typeof self === 'object' && self.self === self && self) ||
  (typeof global === 'object' && global.global === global && global) ||
  this
);

const has = type => typeof root[type] !== 'undefined';
const is = (value, type) => has(type) && value instanceof root[type];


const Utils = {}

Utils.toArray = data => {
  // if Buffer exists in global context, use Buffer
  if (has('Buffer')) {
    const buf = root.Buffer.from(data);
    return [...buf];
  }

  // TypedArray
  if (is(data, 'TypedArray')) {
    const u8 = new Uint8Array(data.buffer);
    return [...u8];
  }

  // string
  if (typeof data === 'string') {
    const bytestring = unescape(encodeURIComponent(data));
    return [...bytestring].map(c => c.charCodeAt(0));
  }

  // other array-like objects
  const arr = Array.from(data);

  for (let i = 0; i < arr.length; i++) {
    const b = arr[i];

    if (!Number.isInteger(b) || b < 0x00 || 0xff < b)
      console.error(`Given data is not a byte array (data[${i}] = ${b}))`);
  }

  return arr;
};

// Available sizes
const SIZES = [16, 24, 32];

// ROUNDS [blockSize] [keySize]
const ROUNDS = {
  '16': { '16': 10, '24': 12, '32': 14 },
  '24': { '16': 12, '24': 12, '32': 14 },
  '32': { '16': 14, '24': 14, '32': 14 },
};

const SBOX = Precalculated.SBOX;
const RCON = Precalculated.RCON;
const ROW_SHIFT = Precalculated.ROW_SHIFT;

const MUL_02 = Precalculated.MUL2;
const MUL_03 = Precalculated.MUL3;
const MUL_09 = Precalculated.MUL9;
const MUL_11 = Precalculated.MUL11;
const MUL_13 = Precalculated.MUL13;
const MUL_14 = Precalculated.MUL14;

//==============================================================================

class Rijndael {
  constructor(key) {
    const keySize = key.length;

    if (!SIZES.includes(keySize))
      console.error(`Unsupported key size: ${keySize * 8}bit`);

    this.key = Utils.toArray(key);
    this.keySize = keySize;
  }

  ExpandKey(blockSize) {
    const keySize = this.keySize;
    const roundCount = ROUNDS[blockSize][keySize];
    const keyCount = roundCount + 1;
    const expandedKey = new Array(keyCount * blockSize);

    // First key is original key
    for (let i = 0; i < keySize; i++) expandedKey[i] = this.key[i];

    let rconIndex = 0;

    for (let i = keySize; i < expandedKey.length; i += 4) {
      // Take previous word
      let temp = expandedKey.slice(i - 4, i);

      // First 4 bytes
      if (i % keySize === 0) {
        // Key Schedule Core
        // 1. Rotate 8 bit left
        // 2. Apply S-box on every byte
        // 3. First byte ^= RCON[rconIndex]
        temp = [
          SBOX[temp[1]] ^ RCON[rconIndex],
          SBOX[temp[2]],
          SBOX[temp[3]],
          SBOX[temp[0]],
        ];

        // Use next RCON
        rconIndex++;
      }

      // Fill three word
      if (i % keySize < 16) {
        for (let j = 0; j < 4; j++)
          expandedKey[i + j] = expandedKey[i - keySize + j] ^ temp[j];
      }

      // End of 128 bit key processing
      if (keySize === 16) continue;

      // For 256 bit key
      if (keySize === 32 && i % keySize === 16) {
        temp = [
          SBOX[temp[0]],
          SBOX[temp[1]],
          SBOX[temp[2]],
          SBOX[temp[3]],
        ];

        for (let j = 0; j < 4; j++)
          expandedKey[i + j] = expandedKey[i - keySize + j] ^ temp[j];
      }
      // For 192 bit and 256 bit key, fill left one/three blocks
      else {
        for (let j = 0; j < 4; j++)
          expandedKey[i + j] = expandedKey[i - keySize + j] ^ temp[j];
      }
    }

    return expandedKey;
  }

  AddRoundKey(block, key, keyIndex) {
    const blockSize = block.length;

    for (let i = 0; i < blockSize; i++)
      block[i] ^= key[keyIndex * blockSize + i];
  }

  SubBytes(block) {
    for (let i = 0; i < block.length; i++)
      block[i] = SBOX[block[i]];
  }

  SubBytesReversed(block) {
    for (let i = 0; i < block.length; i++)
      block[i] = SBOX.indexOf(block[i]);
  }

  ShiftRows(block) {
    const output = [];

    for (let i = 0; i < block.length; i++)
      output[i] = block[ROW_SHIFT[block.length][i]];

    for (let i = 0; i < block.length; i++)
      block[i] = output[i];
  }

  ShiftRowsReversed(block) {
    const output = [];

    for (let i = 0; i < block.length; i++)
      output[i] = block[ROW_SHIFT[block.length].indexOf(i)];

    for (let i = 0; i < block.length; i++)
      block[i] = output[i];
  }

  MixColumns(block) {
    for (let i = 0; i < block.length; i += 4) {
      // b0 = 2a0 + 3a1 + 1a2 + 1a3
      // b1 = 1a0 + 2a1 + 3a2 + 1a3
      // b2 = 1a0 + 1a1 + 2a2 + 3a3
      // b3 = 3a0 + 1a1 + 1a2 + 2a3
      let a = block.slice(i, i + 4);
      let b = [
        MUL_02[a[0]] ^ MUL_03[a[1]] ^ a[2] ^ a[3],
        a[0] ^ MUL_02[a[1]] ^ MUL_03[a[2]] ^ a[3],
        a[0] ^ a[1] ^ MUL_02[a[2]] ^ MUL_03[a[3]],
        MUL_03[a[0]] ^ a[1] ^ a[2] ^ MUL_02[a[3]],
      ];

      block[i + 0] = b[0];
      block[i + 1] = b[1];
      block[i + 2] = b[2];
      block[i + 3] = b[3];
    }
  }

  MixColumnsReversed(block) {
    for (let i = 0; i < block.length; i += 4) {
      // a0 = 14b0 + 11b1 + 13b2 +  9b3
      // a1 =  9b0 + 14b1 + 11b2 + 13b3
      // a2 = 13b0 +  9b1 + 14b2 + 11b3
      // a3 = 11b0 + 13b1 +  9b2 + 14b3
      let b = block.slice(i, i + 4);
      let a = [
        MUL_14[b[0]] ^ MUL_11[b[1]] ^ MUL_13[b[2]] ^ MUL_09[b[3]],
        MUL_09[b[0]] ^ MUL_14[b[1]] ^ MUL_11[b[2]] ^ MUL_13[b[3]],
        MUL_13[b[0]] ^ MUL_09[b[1]] ^ MUL_14[b[2]] ^ MUL_11[b[3]],
        MUL_11[b[0]] ^ MUL_13[b[1]] ^ MUL_09[b[2]] ^ MUL_14[b[3]],
      ];

      block[i + 0] = a[0];
      block[i + 1] = a[1];
      block[i + 2] = a[2];
      block[i + 3] = a[3];
    }
  }

  encrypt(_block) {
    const block = Utils.toArray(_block);

    const blockSize = block.length;
    const keySize = this.keySize;
    const roundCount = ROUNDS[blockSize][keySize];

    if (!SIZES.includes(blockSize))
      console.error(`Unsupported block size: ${blockSize * 8}bit`);

    // Calculations are made to this state
    const state = block.slice();

    // Key Expansion
    const expandedKey = this.ExpandKey(blockSize);

    // Initial Round
    this.AddRoundKey(state, expandedKey, 0);

    // Rounds
    for (let round = 1; round < roundCount; round++) {
      this.SubBytes(state);
      this.ShiftRows(state);
      this.MixColumns(state);
      this.AddRoundKey(state, expandedKey, round);
    }

    // Final Round
    this.SubBytes(state);
    this.ShiftRows(state);
    this.AddRoundKey(state, expandedKey, roundCount);

    return state;
  }

  decrypt(_block) {
    const block = Utils.toArray(_block);

    const blockSize = block.length;
    const keySize = this.keySize;
    const roundCount = ROUNDS[blockSize][keySize];

    if (!SIZES.includes(blockSize))
      console.error(`Unsupported block size: ${blockSize * 8}bit`);

    // Calculations are made to this state
    const state = block.slice();

    // Key Expansion
    const expandedKey = this.ExpandKey(blockSize);

    // Final Round (Reversed)
    this.AddRoundKey(state, expandedKey, roundCount);
    this.ShiftRowsReversed(state);
    this.SubBytesReversed(state);

    // Rounds (Reversed)
    for (let round = roundCount - 1; 1 <= round; round--) {
      this.AddRoundKey(state, expandedKey, round);
      this.MixColumnsReversed(state);
      this.ShiftRowsReversed(state);
      this.SubBytesReversed(state);
    }

    // Initial Round (Reversed)
    this.AddRoundKey(state, expandedKey, 0);

    return state;
  }
}

// Available sizes, modes
const MODES = ['ecb', 'cbc'];

//==============================================================================

class RijndaelBlock {
  constructor(key, mode) {
    let keySize = key.length;

    if (!SIZES.includes(keySize))
      console.error(`Unsupported key size: ${keySize * 8} bit`);

    if (!MODES.includes(mode))
      console.error(`Unsupported mode: ${mode}`);

    this.key = Utils.toArray(key);
    this.keySize = keySize;
    this.mode = mode;
  }

  encrypt(_plaintext, blockSize, _iv) {
    blockSize = parseInt(blockSize);

    if (blockSize <= 32 && !SIZES.includes(blockSize))
      console.error(`Unsupported block size: ${blockSize * 8} bit`);

    else if (32 < blockSize) {
      blockSize /= 8;

      if (!SIZES.includes(blockSize))
        console.error(`Unsupported block size: ${blockSize} bit`);
    }

    if (this.mode === 'cbc') {
      if (!_iv)
        console.error(`IV is required for mode ${this.mode}`);

      if (_iv.length !== blockSize)
        console.error(`IV size should match with block size (${blockSize * 8} bit)`);
    }

    const plaintext = Utils.toArray(_plaintext);
    let padLength = plaintext.length % blockSize;
    if (padLength !== 0) padLength = blockSize - padLength;
    while (padLength-- > 0) plaintext.push(0);

    const blockCount = plaintext.length / blockSize;
    const ciphertext = new Array(plaintext.length);

    const cipher = new Rijndael(this.key);

    switch (this.mode) {
      case 'ecb':
        for (let i = 0; i < blockCount; i++) {
          const start = i * blockSize;
          const end = (i + 1) * blockSize;
          const block = plaintext.slice(start, end);

          const encrypted = cipher.encrypt(block);

          for (let j = 0; j < blockSize; j++)
            ciphertext[start + j] = encrypted[j];
        }

        break;

      case 'cbc':
        let iv = Utils.toArray(_iv);

        for (let i = 0; i < blockCount; i++) {
          const start = i * blockSize;
          const end = (i + 1) * blockSize;
          const block = plaintext.slice(start, end);

          for (let j = 0; j < blockSize; j++)
            block[j] ^= iv[j];

          const encrypted = cipher.encrypt(block);

          for (let j = 0; j < blockSize; j++)
            ciphertext[start + j] = encrypted[j];

          iv = encrypted.slice();
        }

        break;
    }

    return ciphertext;
  }

  decrypt(_ciphertext, blockSize, _iv) {
    blockSize = parseInt(blockSize);

    if (blockSize <= 32 && !SIZES.includes(blockSize))
      console.error(`Unsupported block size: ${blockSize * 8} bit`);

    else if (32 < blockSize) {
      blockSize /= 8;

      if (!SIZES.includes(blockSize))
        console.error(`Unsupported block size: ${blockSize} bit`);
    }

    if (this.mode === 'cbc') {
      if (!_iv)
        console.error(`IV is required for mode ${this.mode}`);

      if (_iv.length !== blockSize)
        console.error(`IV size should match with block size (${blockSize * 8} bit)`);
    }

    const ciphertext = Utils.toArray(_ciphertext);
    if (ciphertext.length % blockSize !== 0)
      console.error(`Ciphertext length should be multiple of ${blockSize * 8} bit`);

    const blockCount = ciphertext.length / blockSize;
    const plaintext = new Array(ciphertext.length);

    const cipher = new Rijndael(this.key);

    switch (this.mode) {
      case 'ecb':
        for (let i = 0; i < blockCount; i++) {
          const start = i * blockSize;
          const end = (i + 1) * blockSize;
          const block = ciphertext.slice(start, end);

          const decrypted = cipher.decrypt(block);

          for (let j = 0; j < blockSize; j++)
            plaintext[start + j] = decrypted[j];
        }

        break;

      case 'cbc':
        let iv = Utils.toArray(_iv);

        for (let i = 0; i < blockCount; i++) {
          const start = i * blockSize;
          const end = (i + 1) * blockSize;
          const block = ciphertext.slice(start, end);

          const decrypted = cipher.decrypt(block);

          for (let j = 0; j < blockSize; j++)
            plaintext[start + j] = decrypted[j] ^ iv[j];

          iv = block.slice();
        }

        break;
    }
    return plaintext;
  }
}
